// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AnalyticsFieldType.
const (
	Boolean AnalyticsFieldType = "boolean"
	Number  AnalyticsFieldType = "number"
	Other   AnalyticsFieldType = "other"
	String  AnalyticsFieldType = "string"
	Time    AnalyticsFieldType = "time"
)

// Defines values for DeploymentStatus.
const (
	DeploymentStatusFailed  DeploymentStatus = "failed"
	DeploymentStatusPending DeploymentStatus = "pending"
	DeploymentStatusSuccess DeploymentStatus = "success"
)

// Defines values for Encoding.
const (
	Base64 Encoding = "base64"
	Utf8   Encoding = "utf-8"
)

// Defines values for FileAssetKind.
const (
	FileAssetKindFile FileAssetKind = "file"
)

// Defines values for LogLevel.
const (
	Debug   LogLevel = "debug"
	Error   LogLevel = "error"
	Info    LogLevel = "info"
	Warning LogLevel = "warning"
)

// Defines values for LogOrder.
const (
	TimeAsc  LogOrder = "timeAsc"
	TimeDesc LogOrder = "timeDesc"
)

// Defines values for ProvisioningStatusFailedCode.
const (
	ProvisioningStatusFailedCodeFailed ProvisioningStatusFailedCode = "failed"
)

// Defines values for ProvisioningStatusManualCode.
const (
	Manual ProvisioningStatusManualCode = "manual"
)

// Defines values for ProvisioningStatusPendingCode.
const (
	Pending ProvisioningStatusPendingCode = "pending"
)

// Defines values for ProvisioningStatusSuccessCode.
const (
	Success ProvisioningStatusSuccessCode = "success"
)

// Defines values for Region.
const (
	GcpAsiaEast1              Region = "gcp-asia-east1"
	GcpAsiaEast2              Region = "gcp-asia-east2"
	GcpAsiaNortheast1         Region = "gcp-asia-northeast1"
	GcpAsiaNortheast2         Region = "gcp-asia-northeast2"
	GcpAsiaNortheast3         Region = "gcp-asia-northeast3"
	GcpAsiaSouth1             Region = "gcp-asia-south1"
	GcpAsiaSouth2             Region = "gcp-asia-south2"
	GcpAsiaSoutheast1         Region = "gcp-asia-southeast1"
	GcpAsiaSoutheast2         Region = "gcp-asia-southeast2"
	GcpAustraliaSoutheast1    Region = "gcp-australia-southeast1"
	GcpAustraliaSoutheast2    Region = "gcp-australia-southeast2"
	GcpEuropeCentral2         Region = "gcp-europe-central2"
	GcpEuropeNorth1           Region = "gcp-europe-north1"
	GcpEuropeSouthwest1       Region = "gcp-europe-southwest1"
	GcpEuropeWest1            Region = "gcp-europe-west1"
	GcpEuropeWest2            Region = "gcp-europe-west2"
	GcpEuropeWest3            Region = "gcp-europe-west3"
	GcpEuropeWest4            Region = "gcp-europe-west4"
	GcpEuropeWest6            Region = "gcp-europe-west6"
	GcpEuropeWest8            Region = "gcp-europe-west8"
	GcpMeWest1                Region = "gcp-me-west1"
	GcpNorthamericaNortheast1 Region = "gcp-northamerica-northeast1"
	GcpNorthamericaNortheast2 Region = "gcp-northamerica-northeast2"
	GcpSouthamericaEast1      Region = "gcp-southamerica-east1"
	GcpSouthamericaWest1      Region = "gcp-southamerica-west1"
	GcpUsCentral1             Region = "gcp-us-central1"
	GcpUsEast1                Region = "gcp-us-east1"
	GcpUsEast4                Region = "gcp-us-east4"
	GcpUsEast5                Region = "gcp-us-east5"
	GcpUsSouth1               Region = "gcp-us-south1"
	GcpUsWest1                Region = "gcp-us-west1"
	GcpUsWest2                Region = "gcp-us-west2"
	GcpUsWest3                Region = "gcp-us-west3"
	GcpUsWest4                Region = "gcp-us-west4"
)

// Defines values for SymlinkAssetKind.
const (
	SymlinkAssetKindSymlink SymlinkAssetKind = "symlink"
)

// Defines values for TlsCipher.
const (
	Ec  TlsCipher = "ec"
	Rsa TlsCipher = "rsa"
)

// AddDomainCertificateRequest defines model for AddDomainCertificateRequest.
type AddDomainCertificateRequest struct {
	// CertificateChain The PRM encoded certificate chain for the TLS certificate
	CertificateChain string `json:"certificateChain"`

	// PrivateKey The PEM encoded private key for the TLS certificate
	PrivateKey string `json:"privateKey"`
}

// Analytics Project analytics data
type Analytics struct {
	Fields []AnalyticsFieldSchema `json:"fields"`
	Values [][]AnalyticsDataValue `json:"values"`
}

// AnalyticsDataValue defines model for AnalyticsDataValue.
type AnalyticsDataValue struct {
	union json.RawMessage
}

// AnalyticsDataValue0 defines model for .
type AnalyticsDataValue0 = time.Time

// AnalyticsDataValue1 defines model for .
type AnalyticsDataValue1 = float64

// AnalyticsDataValue2 defines model for .
type AnalyticsDataValue2 = string

// AnalyticsDataValue3 defines model for .
type AnalyticsDataValue3 = bool

// AnalyticsDataValue4 defines model for .
type AnalyticsDataValue4 = interface{}

// AnalyticsFieldSchema defines model for AnalyticsFieldSchema.
type AnalyticsFieldSchema struct {
	Name string `json:"name"`

	// Type A data type that analytic data can be represented in.
	//
	// Inspired by Grafana's data types defined at:
	// https://github.com/grafana/grafana/blob/e3288834b37b9aac10c1f43f0e621b35874c1f8a/packages/grafana-data/src/types/dataFrame.ts#L11-L23
	Type AnalyticsFieldType `json:"type"`
}

// AnalyticsFieldType A data type that analytic data can be represented in.
//
// Inspired by Grafana's data types defined at:
// https://github.com/grafana/grafana/blob/e3288834b37b9aac10c1f43f0e621b35874c1f8a/packages/grafana-data/src/types/dataFrame.ts#L11-L23
type AnalyticsFieldType string

// AppLogsResponseEntry defines model for AppLogsResponseEntry.
type AppLogsResponseEntry struct {
	Level   LogLevel `json:"level"`
	Message string   `json:"message"`
	Region  Region   `json:"region"`

	// Time Log timestamp
	Time time.Time `json:"time"`
}

// Asset defines model for Asset.
type Asset struct {
	union json.RawMessage
}

// Assets A map whose key represents a file path, and the value is an asset that
// composes the deployment.
//
// Each asset is one of the following three kinds:
//
// 1. A file with content data (which is UTF-8 for text, or base64 for binary)
// 2. A file with a hash
// 3. A symbolic link to another asset
//
// Assets that were uploaded in some of the previous deployments don't need to
// be uploaded again. In this case, in order to identify the asset, just
// provide the SHA-1 hash of the content.
type Assets map[string]Asset

// BuildLogsResponseEntry defines model for BuildLogsResponseEntry.
type BuildLogsResponseEntry struct {
	Level   string `json:"level"`
	Message string `json:"message"`
}

// CompilerOptions Compiler options to be used when building the deployment.
//
// If `null` is given, Deno's config file (i.e. `deno.json` or `deno.jsonc`)
// will be auto-discovered, which may contain a `compilerOptions` field. If
// found, that compiler options will be applied.
//
// If an empty object `{}` is given, [the default compiler options](https://docs.deno.com/runtime/manual/advanced/typescript/configuration#how-deno-uses-a-configuration-file)
// will be applied.
type CompilerOptions struct {
	Jsx                *string `json:"jsx"`
	JsxFactory         *string `json:"jsxFactory"`
	JsxFragmentFactory *string `json:"jsxFragmentFactory"`
	JsxImportSource    *string `json:"jsxImportSource"`
}

// CreateDeploymentRequest defines model for CreateDeploymentRequest.
type CreateDeploymentRequest struct {
	// Assets A map whose key represents a file path, and the value is an asset that
	// composes the deployment.
	//
	// Each asset is one of the following three kinds:
	//
	// 1. A file with content data (which is UTF-8 for text, or base64 for binary)
	// 2. A file with a hash
	// 3. A symbolic link to another asset
	//
	// Assets that were uploaded in some of the previous deployments don't need to
	// be uploaded again. In this case, in order to identify the asset, just
	// provide the SHA-1 hash of the content.
	Assets          Assets           `json:"assets"`
	CompilerOptions *CompilerOptions `json:"compilerOptions"`

	// EntryPointUrl An URL of the entry point of the application.
	// This is the file that will be executed when the deployment is invoked.
	EntryPointUrl string `json:"entryPointUrl"`

	// EnvVars A dictionary of environment variables to be set in the runtime environment
	// of the deployment.
	EnvVars map[string]string `json:"envVars"`

	// ImportMapUrl An URL of the import map file.
	//
	// If `null` is given, import map auto-discovery logic will be performed,
	// where it looks for Deno's config file (i.e. `deno.json` or `deno.jsonc`)
	// which may contain an embedded import map or a path to an import map file.
	// If found, that import map will be used.
	//
	// If an empty string is given, no import map will be used.
	ImportMapUrl *string `json:"importMapUrl"`

	// LockFileUrl An URL of the lock file.
	//
	// If `null` is given, lock file auto-discovery logic will be performed,
	// where it looks for Deno's config file (i.e. `deno.json` or `deno.jsonc`)
	// which may contain a path to a lock file or boolean value, such as `"lock":
	// false` or `"lock": "my-lock.lock"`. If a config file is found, the
	// semantics of the lock field is the same as the Deno CLI, so refer to [the
	// CLI doc page](https://docs.deno.com/runtime/manual/basics/modules/integrity_checking#auto-generated-lockfile).
	//
	// If an empty string is given, no lock file will be used.
	LockFileUrl *string `json:"lockFileUrl"`
}

// CreateDomainRequest defines model for CreateDomainRequest.
type CreateDomainRequest struct {
	Domain string `json:"domain"`
}

// CreateProjectRequest defines model for CreateProjectRequest.
type CreateProjectRequest struct {
	// Name The name of the project. If this is `null`, a random name will be
	// generated.
	Name *string `json:"name"`
}

// CursorLinkHeader Pagination links.
// This header provides a URL for the `next` page.
// The format conforms to [RFC 8288](https://tools.ietf.org/html/rfc8288).
type CursorLinkHeader = string

// Deployment defines model for Deployment.
type Deployment struct {
	CreatedAt time.Time `json:"createdAt"`
	Domains   *[]string `json:"domains"`

	// Id A deployment ID
	//
	// Note that this is not UUID v4, as opposed to organization ID and project ID.
	Id        DeploymentId       `json:"id"`
	ProjectId openapi_types.UUID `json:"projectId"`

	// Status The status of a deployment.
	Status    DeploymentStatus `json:"status"`
	UpdatedAt time.Time        `json:"updatedAt"`
}

// DeploymentId A deployment ID
//
// Note that this is not UUID v4, as opposed to organization ID and project ID.
type DeploymentId = string

// DeploymentStatus The status of a deployment.
type DeploymentStatus string

// DnsRecord defines model for DnsRecord.
type DnsRecord struct {
	Content string `json:"content"`
	Name    string `json:"name"`
	Type    string `json:"type"`
}

// Domain defines model for Domain.
type Domain struct {
	// Certificates TLS certificates for the domain.
	Certificates []DomainCertificate `json:"certificates"`
	CreatedAt    time.Time           `json:"createdAt"`

	// DnsRecords These records are used to verify the ownership of the domain.
	DnsRecords []DnsRecord `json:"dnsRecords"`

	// Domain The domain value.
	Domain string `json:"domain"`

	// Id The ID of the domain.
	Id openapi_types.UUID `json:"id"`

	// IsValidated Whether the domain's ownership is validated or not.
	IsValidated bool `json:"isValidated"`

	// OrganizationId The ID of the organization that the domain is associated with.
	OrganizationId openapi_types.UUID `json:"organizationId"`

	// ProjectId The ID of the project that the domain is associated with.
	//
	// If the domain is not associated with any project, this field is omitted.
	ProjectId          *openapi_types.UUID `json:"projectId"`
	ProvisioningStatus ProvisioningStatus  `json:"provisioningStatus"`
	Token              string              `json:"token"`
	UpdatedAt          time.Time           `json:"updatedAt"`
}

// DomainCertificate defines model for DomainCertificate.
type DomainCertificate struct {
	Cipher    TlsCipher `json:"cipher"`
	CreatedAt time.Time `json:"createdAt"`
	ExpiresAt time.Time `json:"expiresAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// Encoding defines model for Encoding.
type Encoding string

// ErrorBody defines model for ErrorBody.
type ErrorBody struct {
	// Code The error code
	Code string `json:"code"`

	// Message The error message
	Message string `json:"message"`
}

// File defines model for File.
type File struct {
	union json.RawMessage
}

// File0 defines model for .
type File0 struct {
	Content  string    `json:"content"`
	Encoding *Encoding `json:"encoding,omitempty"`
}

// File1 defines model for .
type File1 struct {
	GitSha1 string `json:"gitSha1"`
}

// FileAsset defines model for FileAsset.
type FileAsset struct {
	Kind  FileAssetKind `json:"kind"`
	union json.RawMessage
}

// FileAssetKind defines model for FileAsset.Kind.
type FileAssetKind string

// FileAsset0 defines model for .
type FileAsset0 struct {
	Content  string    `json:"content"`
	Encoding *Encoding `json:"encoding,omitempty"`
}

// FileAsset1 defines model for .
type FileAsset1 struct {
	GitSha1 string `json:"gitSha1"`
}

// LogLevel defines model for LogLevel.
type LogLevel string

// LogOrder defines model for LogOrder.
type LogOrder string

// Organization defines model for Organization.
type Organization struct {
	CreatedAt time.Time          `json:"createdAt"`
	Id        openapi_types.UUID `json:"id"`
	Name      string             `json:"name"`
	UpdatedAt time.Time          `json:"updatedAt"`
}

// PaginationLinkHeader Pagination links.
// This header provides URLS for the `prev`, `next`, `first`, and `last` pages.
// The format conforms to [RFC 8288](https://tools.ietf.org/html/rfc8288).
type PaginationLinkHeader = string

// Project defines model for Project.
type Project struct {
	CreatedAt time.Time          `json:"createdAt"`
	Id        openapi_types.UUID `json:"id"`
	Name      string             `json:"name"`
	UpdatedAt time.Time          `json:"updatedAt"`
}

// ProvisioningStatus defines model for ProvisioningStatus.
type ProvisioningStatus struct {
	union json.RawMessage
}

// ProvisioningStatusFailed defines model for ProvisioningStatusFailed.
type ProvisioningStatusFailed struct {
	Code    ProvisioningStatusFailedCode `json:"code"`
	Message string                       `json:"message"`
}

// ProvisioningStatusFailedCode defines model for ProvisioningStatusFailed.Code.
type ProvisioningStatusFailedCode string

// ProvisioningStatusManual defines model for ProvisioningStatusManual.
type ProvisioningStatusManual struct {
	Code ProvisioningStatusManualCode `json:"code"`
}

// ProvisioningStatusManualCode defines model for ProvisioningStatusManual.Code.
type ProvisioningStatusManualCode string

// ProvisioningStatusPending defines model for ProvisioningStatusPending.
type ProvisioningStatusPending struct {
	Code ProvisioningStatusPendingCode `json:"code"`
}

// ProvisioningStatusPendingCode defines model for ProvisioningStatusPending.Code.
type ProvisioningStatusPendingCode string

// ProvisioningStatusSuccess defines model for ProvisioningStatusSuccess.
type ProvisioningStatusSuccess struct {
	Code ProvisioningStatusSuccessCode `json:"code"`
}

// ProvisioningStatusSuccessCode defines model for ProvisioningStatusSuccess.Code.
type ProvisioningStatusSuccessCode string

// Region defines model for Region.
type Region string

// Symlink defines model for Symlink.
type Symlink struct {
	Target string `json:"target"`
}

// SymlinkAsset defines model for SymlinkAsset.
type SymlinkAsset struct {
	Kind   SymlinkAssetKind `json:"kind"`
	Target string           `json:"target"`
}

// SymlinkAssetKind defines model for SymlinkAsset.Kind.
type SymlinkAssetKind string

// TlsCipher defines model for TlsCipher.
type TlsCipher string

// UpdateDomainAssociationRequest defines model for UpdateDomainAssociationRequest.
type UpdateDomainAssociationRequest struct {
	DeploymentId *DeploymentId `json:"deploymentId"`
}

// UpdateProjectRequest defines model for UpdateProjectRequest.
type UpdateProjectRequest struct {
	Name string `json:"name"`
}

// GetAppLogsParams defines parameters for GetAppLogs.
type GetAppLogsParams struct {
	// Q Text to search for in log message.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Level Log level(s) to filter logs by.
	//
	// Defaults to all levels (i.e. no filter applied).
	//
	// Multiple levels can be specified using comma-separated format.
	Level *LogLevel `form:"level,omitempty" json:"level,omitempty"`

	// Region Region(s) to filter logs by.
	//
	// Defaults to all regions (i.e. no filter applied).
	//
	// Multiple regions can be specified using comma-separated format.
	Region *Region `form:"region,omitempty" json:"region,omitempty"`

	// Since Start time of the time range to filter logs by.
	//
	// Defaults to the Unix Epoch (though the log retention period is 2 weeks as
	// of now).
	//
	// If neither `since` nor `until` is specified, real-time logs are returned.
	Since *time.Time `form:"since,omitempty" json:"since,omitempty"`

	// Until End time of the time range to filter logs by.
	//
	// Defaults to the current time.
	//
	// If neither `since` nor `until` is specified, real-time logs are returned.
	Until *time.Time `form:"until,omitempty" json:"until,omitempty"`

	// Limit Maximum number of logs to return in one request.
	//
	// This is only effective for the past log mode.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Order of logs to return.
	Order *LogOrder `form:"order,omitempty" json:"order,omitempty"`

	// Cursor Opaque value that represents the cursor of the last log returned in the
	// previous request.
	//
	// This is only effective for the past log mode.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// ListDomainsParams defines parameters for ListDomains.
type ListDomainsParams struct {
	Page  *int `form:"page,omitempty" json:"page,omitempty"`
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	Page  *int `form:"page,omitempty" json:"page,omitempty"`
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListDeploymentsParams defines parameters for ListDeployments.
type ListDeploymentsParams struct {
	Page  *int `form:"page,omitempty" json:"page,omitempty"`
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// UpdateDomainAssociationJSONRequestBody defines body for UpdateDomainAssociation for application/json ContentType.
type UpdateDomainAssociationJSONRequestBody = UpdateDomainAssociationRequest

// AddDomainCertificateJSONRequestBody defines body for AddDomainCertificate for application/json ContentType.
type AddDomainCertificateJSONRequestBody = AddDomainCertificateRequest

// CreateDomainJSONRequestBody defines body for CreateDomain for application/json ContentType.
type CreateDomainJSONRequestBody = CreateDomainRequest

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = CreateProjectRequest

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody = UpdateProjectRequest

// CreateDeploymentJSONRequestBody defines body for CreateDeployment for application/json ContentType.
type CreateDeploymentJSONRequestBody = CreateDeploymentRequest

// AsAnalyticsDataValue0 returns the union data inside the AnalyticsDataValue as a AnalyticsDataValue0
func (t AnalyticsDataValue) AsAnalyticsDataValue0() (AnalyticsDataValue0, error) {
	var body AnalyticsDataValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsDataValue0 overwrites any union data inside the AnalyticsDataValue as the provided AnalyticsDataValue0
func (t *AnalyticsDataValue) FromAnalyticsDataValue0(v AnalyticsDataValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsDataValue0 performs a merge with any union data inside the AnalyticsDataValue, using the provided AnalyticsDataValue0
func (t *AnalyticsDataValue) MergeAnalyticsDataValue0(v AnalyticsDataValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsDataValue1 returns the union data inside the AnalyticsDataValue as a AnalyticsDataValue1
func (t AnalyticsDataValue) AsAnalyticsDataValue1() (AnalyticsDataValue1, error) {
	var body AnalyticsDataValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsDataValue1 overwrites any union data inside the AnalyticsDataValue as the provided AnalyticsDataValue1
func (t *AnalyticsDataValue) FromAnalyticsDataValue1(v AnalyticsDataValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsDataValue1 performs a merge with any union data inside the AnalyticsDataValue, using the provided AnalyticsDataValue1
func (t *AnalyticsDataValue) MergeAnalyticsDataValue1(v AnalyticsDataValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsDataValue2 returns the union data inside the AnalyticsDataValue as a AnalyticsDataValue2
func (t AnalyticsDataValue) AsAnalyticsDataValue2() (AnalyticsDataValue2, error) {
	var body AnalyticsDataValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsDataValue2 overwrites any union data inside the AnalyticsDataValue as the provided AnalyticsDataValue2
func (t *AnalyticsDataValue) FromAnalyticsDataValue2(v AnalyticsDataValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsDataValue2 performs a merge with any union data inside the AnalyticsDataValue, using the provided AnalyticsDataValue2
func (t *AnalyticsDataValue) MergeAnalyticsDataValue2(v AnalyticsDataValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsDataValue3 returns the union data inside the AnalyticsDataValue as a AnalyticsDataValue3
func (t AnalyticsDataValue) AsAnalyticsDataValue3() (AnalyticsDataValue3, error) {
	var body AnalyticsDataValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsDataValue3 overwrites any union data inside the AnalyticsDataValue as the provided AnalyticsDataValue3
func (t *AnalyticsDataValue) FromAnalyticsDataValue3(v AnalyticsDataValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsDataValue3 performs a merge with any union data inside the AnalyticsDataValue, using the provided AnalyticsDataValue3
func (t *AnalyticsDataValue) MergeAnalyticsDataValue3(v AnalyticsDataValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAnalyticsDataValue4 returns the union data inside the AnalyticsDataValue as a AnalyticsDataValue4
func (t AnalyticsDataValue) AsAnalyticsDataValue4() (AnalyticsDataValue4, error) {
	var body AnalyticsDataValue4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnalyticsDataValue4 overwrites any union data inside the AnalyticsDataValue as the provided AnalyticsDataValue4
func (t *AnalyticsDataValue) FromAnalyticsDataValue4(v AnalyticsDataValue4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnalyticsDataValue4 performs a merge with any union data inside the AnalyticsDataValue, using the provided AnalyticsDataValue4
func (t *AnalyticsDataValue) MergeAnalyticsDataValue4(v AnalyticsDataValue4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AnalyticsDataValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AnalyticsDataValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFileAsset returns the union data inside the Asset as a FileAsset
func (t Asset) AsFileAsset() (FileAsset, error) {
	var body FileAsset
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileAsset overwrites any union data inside the Asset as the provided FileAsset
func (t *Asset) FromFileAsset(v FileAsset) error {
	v.Kind = "file"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileAsset performs a merge with any union data inside the Asset, using the provided FileAsset
func (t *Asset) MergeFileAsset(v FileAsset) error {
	v.Kind = "file"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSymlinkAsset returns the union data inside the Asset as a SymlinkAsset
func (t Asset) AsSymlinkAsset() (SymlinkAsset, error) {
	var body SymlinkAsset
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSymlinkAsset overwrites any union data inside the Asset as the provided SymlinkAsset
func (t *Asset) FromSymlinkAsset(v SymlinkAsset) error {
	v.Kind = "symlink"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSymlinkAsset performs a merge with any union data inside the Asset, using the provided SymlinkAsset
func (t *Asset) MergeSymlinkAsset(v SymlinkAsset) error {
	v.Kind = "symlink"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Asset) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Asset) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "file":
		return t.AsFileAsset()
	case "symlink":
		return t.AsSymlinkAsset()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Asset) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Asset) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFile0 returns the union data inside the File as a File0
func (t File) AsFile0() (File0, error) {
	var body File0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFile0 overwrites any union data inside the File as the provided File0
func (t *File) FromFile0(v File0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFile0 performs a merge with any union data inside the File, using the provided File0
func (t *File) MergeFile0(v File0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFile1 returns the union data inside the File as a File1
func (t File) AsFile1() (File1, error) {
	var body File1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFile1 overwrites any union data inside the File as the provided File1
func (t *File) FromFile1(v File1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFile1 performs a merge with any union data inside the File, using the provided File1
func (t *File) MergeFile1(v File1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t File) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *File) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFileAsset0 returns the union data inside the FileAsset as a FileAsset0
func (t FileAsset) AsFileAsset0() (FileAsset0, error) {
	var body FileAsset0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileAsset0 overwrites any union data inside the FileAsset as the provided FileAsset0
func (t *FileAsset) FromFileAsset0(v FileAsset0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileAsset0 performs a merge with any union data inside the FileAsset, using the provided FileAsset0
func (t *FileAsset) MergeFileAsset0(v FileAsset0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFileAsset1 returns the union data inside the FileAsset as a FileAsset1
func (t FileAsset) AsFileAsset1() (FileAsset1, error) {
	var body FileAsset1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileAsset1 overwrites any union data inside the FileAsset as the provided FileAsset1
func (t *FileAsset) FromFileAsset1(v FileAsset1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileAsset1 performs a merge with any union data inside the FileAsset, using the provided FileAsset1
func (t *FileAsset) MergeFileAsset1(v FileAsset1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t FileAsset) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["kind"], err = json.Marshal(t.Kind)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'kind': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *FileAsset) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["kind"]; found {
		err = json.Unmarshal(raw, &t.Kind)
		if err != nil {
			return fmt.Errorf("error reading 'kind': %w", err)
		}
	}

	return err
}

// AsProvisioningStatusSuccess returns the union data inside the ProvisioningStatus as a ProvisioningStatusSuccess
func (t ProvisioningStatus) AsProvisioningStatusSuccess() (ProvisioningStatusSuccess, error) {
	var body ProvisioningStatusSuccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProvisioningStatusSuccess overwrites any union data inside the ProvisioningStatus as the provided ProvisioningStatusSuccess
func (t *ProvisioningStatus) FromProvisioningStatusSuccess(v ProvisioningStatusSuccess) error {
	v.Code = "success"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProvisioningStatusSuccess performs a merge with any union data inside the ProvisioningStatus, using the provided ProvisioningStatusSuccess
func (t *ProvisioningStatus) MergeProvisioningStatusSuccess(v ProvisioningStatusSuccess) error {
	v.Code = "success"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsProvisioningStatusFailed returns the union data inside the ProvisioningStatus as a ProvisioningStatusFailed
func (t ProvisioningStatus) AsProvisioningStatusFailed() (ProvisioningStatusFailed, error) {
	var body ProvisioningStatusFailed
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProvisioningStatusFailed overwrites any union data inside the ProvisioningStatus as the provided ProvisioningStatusFailed
func (t *ProvisioningStatus) FromProvisioningStatusFailed(v ProvisioningStatusFailed) error {
	v.Code = "failed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProvisioningStatusFailed performs a merge with any union data inside the ProvisioningStatus, using the provided ProvisioningStatusFailed
func (t *ProvisioningStatus) MergeProvisioningStatusFailed(v ProvisioningStatusFailed) error {
	v.Code = "failed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsProvisioningStatusPending returns the union data inside the ProvisioningStatus as a ProvisioningStatusPending
func (t ProvisioningStatus) AsProvisioningStatusPending() (ProvisioningStatusPending, error) {
	var body ProvisioningStatusPending
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProvisioningStatusPending overwrites any union data inside the ProvisioningStatus as the provided ProvisioningStatusPending
func (t *ProvisioningStatus) FromProvisioningStatusPending(v ProvisioningStatusPending) error {
	v.Code = "pending"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProvisioningStatusPending performs a merge with any union data inside the ProvisioningStatus, using the provided ProvisioningStatusPending
func (t *ProvisioningStatus) MergeProvisioningStatusPending(v ProvisioningStatusPending) error {
	v.Code = "pending"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsProvisioningStatusManual returns the union data inside the ProvisioningStatus as a ProvisioningStatusManual
func (t ProvisioningStatus) AsProvisioningStatusManual() (ProvisioningStatusManual, error) {
	var body ProvisioningStatusManual
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProvisioningStatusManual overwrites any union data inside the ProvisioningStatus as the provided ProvisioningStatusManual
func (t *ProvisioningStatus) FromProvisioningStatusManual(v ProvisioningStatusManual) error {
	v.Code = "manual"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProvisioningStatusManual performs a merge with any union data inside the ProvisioningStatus, using the provided ProvisioningStatusManual
func (t *ProvisioningStatus) MergeProvisioningStatusManual(v ProvisioningStatusManual) error {
	v.Code = "manual"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ProvisioningStatus) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"code"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ProvisioningStatus) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "failed":
		return t.AsProvisioningStatusFailed()
	case "manual":
		return t.AsProvisioningStatusManual()
	case "pending":
		return t.AsProvisioningStatusPending()
	case "success":
		return t.AsProvisioningStatusSuccess()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ProvisioningStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ProvisioningStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetDeployment request
	GetDeployment(ctx context.Context, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppLogs request
	GetAppLogs(ctx context.Context, deploymentId string, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBuildLogs request
	GetBuildLogs(ctx context.Context, deploymentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDomain request
	DeleteDomain(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDomain request
	GetDomain(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDomainAssociationWithBody request with any body
	UpdateDomainAssociationWithBody(ctx context.Context, domainId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDomainAssociation(ctx context.Context, domainId openapi_types.UUID, body UpdateDomainAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDomainCertificateWithBody request with any body
	AddDomainCertificateWithBody(ctx context.Context, domainId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDomainCertificate(ctx context.Context, domainId openapi_types.UUID, body AddDomainCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProvisionDomainCertificates request
	ProvisionDomainCertificates(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyDomain request
	VerifyDomain(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganization request
	GetOrganization(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDomains request
	ListDomains(ctx context.Context, organizationId openapi_types.UUID, params *ListDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDomainWithBody request with any body
	CreateDomainWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDomain(ctx context.Context, organizationId openapi_types.UUID, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, organizationId openapi_types.UUID, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectWithBody request with any body
	CreateProjectWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, organizationId openapi_types.UUID, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProject request
	DeleteProject(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectWithBody request with any body
	UpdateProjectWithBody(ctx context.Context, projectId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProject(ctx context.Context, projectId openapi_types.UUID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectAnalytics request
	GetProjectAnalytics(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDeployments request
	ListDeployments(ctx context.Context, projectId openapi_types.UUID, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeploymentWithBody request with any body
	CreateDeploymentWithBody(ctx context.Context, projectId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDeployment(ctx context.Context, projectId openapi_types.UUID, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetDeployment(ctx context.Context, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentRequest(c.Server, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppLogs(ctx context.Context, deploymentId string, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppLogsRequest(c.Server, deploymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBuildLogs(ctx context.Context, deploymentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBuildLogsRequest(c.Server, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDomain(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDomainRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDomain(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDomainRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainAssociationWithBody(ctx context.Context, domainId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainAssociationRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainAssociation(ctx context.Context, domainId openapi_types.UUID, body UpdateDomainAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainAssociationRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDomainCertificateWithBody(ctx context.Context, domainId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDomainCertificateRequestWithBody(c.Server, domainId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDomainCertificate(ctx context.Context, domainId openapi_types.UUID, body AddDomainCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDomainCertificateRequest(c.Server, domainId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProvisionDomainCertificates(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProvisionDomainCertificatesRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyDomain(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyDomainRequest(c.Server, domainId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganization(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDomains(ctx context.Context, organizationId openapi_types.UUID, params *ListDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDomainsRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomainWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomain(ctx context.Context, organizationId openapi_types.UUID, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, organizationId openapi_types.UUID, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, organizationId openapi_types.UUID, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProject(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, projectId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, projectId openapi_types.UUID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectAnalytics(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectAnalyticsRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDeployments(ctx context.Context, projectId openapi_types.UUID, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDeploymentsRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeploymentWithBody(ctx context.Context, projectId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeploymentRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeployment(ctx context.Context, projectId openapi_types.UUID, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeploymentRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetDeploymentRequest generates requests for GetDeployment
func NewGetDeploymentRequest(server string, deploymentId DeploymentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppLogsRequest generates requests for GetAppLogs
func NewGetAppLogsRequest(server string, deploymentId string, params *GetAppLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments/%s/app_logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Level != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "level", runtime.ParamLocationQuery, *params.Level); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBuildLogsRequest generates requests for GetBuildLogs
func NewGetBuildLogsRequest(server string, deploymentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "deploymentId", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deployments/%s/build_logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDomainRequest generates requests for DeleteDomain
func NewDeleteDomainRequest(server string, domainId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDomainRequest generates requests for GetDomain
func NewGetDomainRequest(server string, domainId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDomainAssociationRequest calls the generic UpdateDomainAssociation builder with application/json body
func NewUpdateDomainAssociationRequest(server string, domainId openapi_types.UUID, body UpdateDomainAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDomainAssociationRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewUpdateDomainAssociationRequestWithBody generates requests for UpdateDomainAssociation with any type of body
func NewUpdateDomainAssociationRequestWithBody(server string, domainId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddDomainCertificateRequest calls the generic AddDomainCertificate builder with application/json body
func NewAddDomainCertificateRequest(server string, domainId openapi_types.UUID, body AddDomainCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDomainCertificateRequestWithBody(server, domainId, "application/json", bodyReader)
}

// NewAddDomainCertificateRequestWithBody generates requests for AddDomainCertificate with any type of body
func NewAddDomainCertificateRequestWithBody(server string, domainId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domains/%s/certificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProvisionDomainCertificatesRequest generates requests for ProvisionDomainCertificates
func NewProvisionDomainCertificatesRequest(server string, domainId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domains/%s/certificates/provision", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerifyDomainRequest generates requests for VerifyDomain
func NewVerifyDomainRequest(server string, domainId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domainId", runtime.ParamLocationPath, domainId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domains/%s/verify", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRequest generates requests for GetOrganization
func NewGetOrganizationRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDomainsRequest generates requests for ListDomains
func NewListDomainsRequest(server string, organizationId openapi_types.UUID, params *ListDomainsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/domains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDomainRequest calls the generic CreateDomain builder with application/json body
func NewCreateDomainRequest(server string, organizationId openapi_types.UUID, body CreateDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDomainRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateDomainRequestWithBody generates requests for CreateDomain with any type of body
func NewCreateDomainRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/domains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string, organizationId openapi_types.UUID, params *ListProjectsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, organizationId openapi_types.UUID, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationId", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectRequest generates requests for DeleteProject
func NewDeleteProjectRequest(server string, projectId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, projectId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, projectId openapi_types.UUID, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, projectId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProjectAnalyticsRequest generates requests for GetProjectAnalytics
func NewGetProjectAnalyticsRequest(server string, projectId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/analytics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDeploymentsRequest generates requests for ListDeployments
func NewListDeploymentsRequest(server string, projectId openapi_types.UUID, params *ListDeploymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeploymentRequest calls the generic CreateDeployment builder with application/json body
func NewCreateDeploymentRequest(server string, projectId openapi_types.UUID, body CreateDeploymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeploymentRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateDeploymentRequestWithBody generates requests for CreateDeployment with any type of body
func NewCreateDeploymentRequestWithBody(server string, projectId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectId", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetDeploymentWithResponse request
	GetDeploymentWithResponse(ctx context.Context, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*GetDeploymentResponse, error)

	// GetAppLogsWithResponse request
	GetAppLogsWithResponse(ctx context.Context, deploymentId string, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*GetAppLogsResponse, error)

	// GetBuildLogsWithResponse request
	GetBuildLogsWithResponse(ctx context.Context, deploymentId string, reqEditors ...RequestEditorFn) (*GetBuildLogsResponse, error)

	// DeleteDomainWithResponse request
	DeleteDomainWithResponse(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteDomainResponse, error)

	// GetDomainWithResponse request
	GetDomainWithResponse(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDomainResponse, error)

	// UpdateDomainAssociationWithBodyWithResponse request with any body
	UpdateDomainAssociationWithBodyWithResponse(ctx context.Context, domainId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainAssociationResponse, error)

	UpdateDomainAssociationWithResponse(ctx context.Context, domainId openapi_types.UUID, body UpdateDomainAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainAssociationResponse, error)

	// AddDomainCertificateWithBodyWithResponse request with any body
	AddDomainCertificateWithBodyWithResponse(ctx context.Context, domainId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDomainCertificateResponse, error)

	AddDomainCertificateWithResponse(ctx context.Context, domainId openapi_types.UUID, body AddDomainCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDomainCertificateResponse, error)

	// ProvisionDomainCertificatesWithResponse request
	ProvisionDomainCertificatesWithResponse(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ProvisionDomainCertificatesResponse, error)

	// VerifyDomainWithResponse request
	VerifyDomainWithResponse(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*VerifyDomainResponse, error)

	// GetOrganizationWithResponse request
	GetOrganizationWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetOrganizationResponse, error)

	// ListDomainsWithResponse request
	ListDomainsWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *ListDomainsParams, reqEditors ...RequestEditorFn) (*ListDomainsResponse, error)

	// CreateDomainWithBodyWithResponse request with any body
	CreateDomainWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error)

	CreateDomainWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error)

	// ListProjectsWithResponse request
	ListProjectsWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error)

	// CreateProjectWithBodyWithResponse request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	CreateProjectWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	// DeleteProjectWithResponse request
	DeleteProjectWithResponse(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error)

	// GetProjectWithResponse request
	GetProjectWithResponse(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetProjectResponse, error)

	// UpdateProjectWithBodyWithResponse request with any body
	UpdateProjectWithBodyWithResponse(ctx context.Context, projectId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	UpdateProjectWithResponse(ctx context.Context, projectId openapi_types.UUID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	// GetProjectAnalyticsWithResponse request
	GetProjectAnalyticsWithResponse(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetProjectAnalyticsResponse, error)

	// ListDeploymentsWithResponse request
	ListDeploymentsWithResponse(ctx context.Context, projectId openapi_types.UUID, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*ListDeploymentsResponse, error)

	// CreateDeploymentWithBodyWithResponse request with any body
	CreateDeploymentWithBodyWithResponse(ctx context.Context, projectId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)

	CreateDeploymentWithResponse(ctx context.Context, projectId openapi_types.UUID, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error)
}

type GetDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deployment
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r GetDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AppLogsResponseEntry
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r GetAppLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBuildLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BuildLogsResponseEntry
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r GetBuildLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBuildLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r DeleteDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Domain
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r GetDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDomainAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UpdateDomainAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDomainAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDomainCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r AddDomainCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDomainCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProvisionDomainCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r ProvisionDomainCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProvisionDomainCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r VerifyDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r GetOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Domain
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r ListDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Domain
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r CreateDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Project
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r ListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r CreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r DeleteProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r GetProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UpdateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectAnalyticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Analytics
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r GetProjectAnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectAnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Deployment
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r ListDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deployment
	JSON400      *ErrorBody
	JSON401      *ErrorBody
	JSON404      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r CreateDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetDeploymentWithResponse request returning *GetDeploymentResponse
func (c *ClientWithResponses) GetDeploymentWithResponse(ctx context.Context, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*GetDeploymentResponse, error) {
	rsp, err := c.GetDeployment(ctx, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentResponse(rsp)
}

// GetAppLogsWithResponse request returning *GetAppLogsResponse
func (c *ClientWithResponses) GetAppLogsWithResponse(ctx context.Context, deploymentId string, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*GetAppLogsResponse, error) {
	rsp, err := c.GetAppLogs(ctx, deploymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppLogsResponse(rsp)
}

// GetBuildLogsWithResponse request returning *GetBuildLogsResponse
func (c *ClientWithResponses) GetBuildLogsWithResponse(ctx context.Context, deploymentId string, reqEditors ...RequestEditorFn) (*GetBuildLogsResponse, error) {
	rsp, err := c.GetBuildLogs(ctx, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBuildLogsResponse(rsp)
}

// DeleteDomainWithResponse request returning *DeleteDomainResponse
func (c *ClientWithResponses) DeleteDomainWithResponse(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteDomainResponse, error) {
	rsp, err := c.DeleteDomain(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDomainResponse(rsp)
}

// GetDomainWithResponse request returning *GetDomainResponse
func (c *ClientWithResponses) GetDomainWithResponse(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDomainResponse, error) {
	rsp, err := c.GetDomain(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDomainResponse(rsp)
}

// UpdateDomainAssociationWithBodyWithResponse request with arbitrary body returning *UpdateDomainAssociationResponse
func (c *ClientWithResponses) UpdateDomainAssociationWithBodyWithResponse(ctx context.Context, domainId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainAssociationResponse, error) {
	rsp, err := c.UpdateDomainAssociationWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainAssociationResponse(rsp)
}

func (c *ClientWithResponses) UpdateDomainAssociationWithResponse(ctx context.Context, domainId openapi_types.UUID, body UpdateDomainAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainAssociationResponse, error) {
	rsp, err := c.UpdateDomainAssociation(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainAssociationResponse(rsp)
}

// AddDomainCertificateWithBodyWithResponse request with arbitrary body returning *AddDomainCertificateResponse
func (c *ClientWithResponses) AddDomainCertificateWithBodyWithResponse(ctx context.Context, domainId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDomainCertificateResponse, error) {
	rsp, err := c.AddDomainCertificateWithBody(ctx, domainId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDomainCertificateResponse(rsp)
}

func (c *ClientWithResponses) AddDomainCertificateWithResponse(ctx context.Context, domainId openapi_types.UUID, body AddDomainCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDomainCertificateResponse, error) {
	rsp, err := c.AddDomainCertificate(ctx, domainId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDomainCertificateResponse(rsp)
}

// ProvisionDomainCertificatesWithResponse request returning *ProvisionDomainCertificatesResponse
func (c *ClientWithResponses) ProvisionDomainCertificatesWithResponse(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ProvisionDomainCertificatesResponse, error) {
	rsp, err := c.ProvisionDomainCertificates(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProvisionDomainCertificatesResponse(rsp)
}

// VerifyDomainWithResponse request returning *VerifyDomainResponse
func (c *ClientWithResponses) VerifyDomainWithResponse(ctx context.Context, domainId openapi_types.UUID, reqEditors ...RequestEditorFn) (*VerifyDomainResponse, error) {
	rsp, err := c.VerifyDomain(ctx, domainId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyDomainResponse(rsp)
}

// GetOrganizationWithResponse request returning *GetOrganizationResponse
func (c *ClientWithResponses) GetOrganizationWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetOrganizationResponse, error) {
	rsp, err := c.GetOrganization(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationResponse(rsp)
}

// ListDomainsWithResponse request returning *ListDomainsResponse
func (c *ClientWithResponses) ListDomainsWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *ListDomainsParams, reqEditors ...RequestEditorFn) (*ListDomainsResponse, error) {
	rsp, err := c.ListDomains(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDomainsResponse(rsp)
}

// CreateDomainWithBodyWithResponse request with arbitrary body returning *CreateDomainResponse
func (c *ClientWithResponses) CreateDomainWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error) {
	rsp, err := c.CreateDomainWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainResponse(rsp)
}

func (c *ClientWithResponses) CreateDomainWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error) {
	rsp, err := c.CreateDomain(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainResponse(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResponse
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error) {
	rsp, err := c.ListProjects(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// DeleteProjectWithResponse request returning *DeleteProjectResponse
func (c *ClientWithResponses) DeleteProjectWithResponse(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error) {
	rsp, err := c.DeleteProject(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetProjectResponse, error) {
	rsp, err := c.GetProject(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, projectId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, projectId openapi_types.UUID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// GetProjectAnalyticsWithResponse request returning *GetProjectAnalyticsResponse
func (c *ClientWithResponses) GetProjectAnalyticsWithResponse(ctx context.Context, projectId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetProjectAnalyticsResponse, error) {
	rsp, err := c.GetProjectAnalytics(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectAnalyticsResponse(rsp)
}

// ListDeploymentsWithResponse request returning *ListDeploymentsResponse
func (c *ClientWithResponses) ListDeploymentsWithResponse(ctx context.Context, projectId openapi_types.UUID, params *ListDeploymentsParams, reqEditors ...RequestEditorFn) (*ListDeploymentsResponse, error) {
	rsp, err := c.ListDeployments(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDeploymentsResponse(rsp)
}

// CreateDeploymentWithBodyWithResponse request with arbitrary body returning *CreateDeploymentResponse
func (c *ClientWithResponses) CreateDeploymentWithBodyWithResponse(ctx context.Context, projectId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) {
	rsp, err := c.CreateDeploymentWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeploymentResponse(rsp)
}

func (c *ClientWithResponses) CreateDeploymentWithResponse(ctx context.Context, projectId openapi_types.UUID, body CreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeploymentResponse, error) {
	rsp, err := c.CreateDeployment(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeploymentResponse(rsp)
}

// ParseGetDeploymentResponse parses an HTTP response from a GetDeploymentWithResponse call
func ParseGetDeploymentResponse(rsp *http.Response) (*GetDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAppLogsResponse parses an HTTP response from a GetAppLogsWithResponse call
func ParseGetAppLogsResponse(rsp *http.Response) (*GetAppLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AppLogsResponseEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/x-ndjson) unsupported

	}

	return response, nil
}

// ParseGetBuildLogsResponse parses an HTTP response from a GetBuildLogsWithResponse call
func ParseGetBuildLogsResponse(rsp *http.Response) (*GetBuildLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBuildLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BuildLogsResponseEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/x-ndjson) unsupported

	}

	return response, nil
}

// ParseDeleteDomainResponse parses an HTTP response from a DeleteDomainWithResponse call
func ParseDeleteDomainResponse(rsp *http.Response) (*DeleteDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDomainResponse parses an HTTP response from a GetDomainWithResponse call
func ParseGetDomainResponse(rsp *http.Response) (*GetDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Domain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDomainAssociationResponse parses an HTTP response from a UpdateDomainAssociationWithResponse call
func ParseUpdateDomainAssociationResponse(rsp *http.Response) (*UpdateDomainAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDomainAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddDomainCertificateResponse parses an HTTP response from a AddDomainCertificateWithResponse call
func ParseAddDomainCertificateResponse(rsp *http.Response) (*AddDomainCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDomainCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProvisionDomainCertificatesResponse parses an HTTP response from a ProvisionDomainCertificatesWithResponse call
func ParseProvisionDomainCertificatesResponse(rsp *http.Response) (*ProvisionDomainCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProvisionDomainCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseVerifyDomainResponse parses an HTTP response from a VerifyDomainWithResponse call
func ParseVerifyDomainResponse(rsp *http.Response) (*VerifyDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetOrganizationResponse parses an HTTP response from a GetOrganizationWithResponse call
func ParseGetOrganizationResponse(rsp *http.Response) (*GetOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListDomainsResponse parses an HTTP response from a ListDomainsWithResponse call
func ParseListDomainsResponse(rsp *http.Response) (*ListDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Domain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateDomainResponse parses an HTTP response from a CreateDomainWithResponse call
func ParseCreateDomainResponse(rsp *http.Response) (*CreateDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Domain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListProjectsResponse parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResponse(rsp *http.Response) (*ListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*CreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteProjectResponse parses an HTTP response from a DeleteProjectWithResponse call
func ParseDeleteProjectResponse(rsp *http.Response) (*DeleteProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParseGetProjectResponse(rsp *http.Response) (*GetProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*UpdateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetProjectAnalyticsResponse parses an HTTP response from a GetProjectAnalyticsWithResponse call
func ParseGetProjectAnalyticsResponse(rsp *http.Response) (*GetProjectAnalyticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectAnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Analytics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListDeploymentsResponse parses an HTTP response from a ListDeploymentsWithResponse call
func ParseListDeploymentsResponse(rsp *http.Response) (*ListDeploymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateDeploymentResponse parses an HTTP response from a CreateDeploymentWithResponse call
func ParseCreateDeploymentResponse(rsp *http.Response) (*CreateDeploymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
